//소수란 1과 자기 자신으로만 나누어떨어지는 수를 말한다. 예를 들면 1, 2, 3, 5, 17, 101, 10007 등이 소수이다. 
//이 문제에서는 편의상 1도 소수로 하자.
//알파벳 대소문자로 이루어진 영어 단어가 하나 있을 때, a를 1로, b를 2로, …, z를 26으로, A를 27로, …, Z를 52로 하여 그 합을 구한다. 
//예를 들어 cyworld는 합을 구하면 100이 되고, abcd는 10이 된다.
//이와 같이 구한 수가 소수인 경우, 그 단어를 소수 단어라고 한다. 단어가 주어졌을 때, 
//그 단어가 소수 단어인지 판별하는 프로그램을 작성하시오.
//입력
//첫째 줄에 단어가 주어진다. 단어의 길이는 20자 이하이다. 주어지는 단어는 알파벳 소문자와 대문자만으로 이루어져 있다.
//출력
//아래의 예제와 같은 형식으로 출력을 한다. 소수 단어인 경우에는 It is a prime word.를, 
//아닌 경우에는 It is not a prime word.를 출력한다.
package Bronze2;

import java.util.Scanner;

public class 소수단어_2153 {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		char [] n = sc.next().toCharArray();//단어를 입력받아서 한글자씩 잘라서 배열에 저장한다.
		int result =0;//결과변수를 0으로 선언한다.
		int count =0;
	
		for (int i = 0; i < n.length; i++) {//배열의 길이만큼 반복문을 실행한다.
			if((int)(n[i])>=65&&(int)(n[i])<=90) {//배열[i]가 65보다 크거나같고 90보다 작고 같은경우(대문자일경우)
				result-=38; //result의 값을 -38만큼 더한다. (대문자의 경우 -38을해야 A의경우 27이된다.)
			}else {
				result -=96;//result의 값을 -96만큼 더한다.(소문자의 경우 -96을 해야 a의 경우1이된다.)
			}
			result+=(int)(n[i]);//result에다가 n[i]의 값만큼 더한다. 
			}
			
			//입력받은 수가 abcd일 경우 result의 값은 10이 된다. abcd가 소수일경우 1과10으로 나누었을때 나머지가0이면 소수가 된다. 하지만 0이 아니므로 abcd는 소수가 아니게된다.
					
					if(result <4 ) {//배열을 돈후 result의 값이 4보다 작을경우  경우
						System.out.println("It is a prime word.");//1~3은 소수이므로 소수라고 말한다.
					}else {//만약 result가 4보다 크다면 
						for (int i = 2; i < result; i++) { //result를 i로 나눈 나머지가 0이 될 경우 count라는 변수에 업을 한다. 
							if(result%i ==0) {
								count++;
							}
						}
						if(count==0) {//count가 0일 경우 result는 소수가 된다.
							System.out.println("It is a prime word.");
						}else {//count가 0이 아닐 경우 result는 소수가 아니다 
							System.out.println("It is not a prime word.");
						}
		}				
	}
}

//1번 이 문제를 푸는 핵심은 입력을 받았을 때 단어를 배열에다가 하나하나 잘라서 숫자로 담아야 한다는점
//배열하나하나의 숫자를 특정 변수에다가 다 더해서 담은 우 아스키코드 소문자 대문자를 문제에서 제시하는 알파벳번호로 치환해주어야한다. (A는 아스키코드로 65고 문제는 27이므로 38을 뺴줘야함)
//그런후 특정 변수의 값이 4보다 작은경우와 4보다 큰경우로 나눈다.
//4보다 작은 경우는 1~3이므로 소수단어가되고 4보다 큰경우에는 소수인 애와 아닌애가 섞였으므로 분별을 해야한다.
//소수는 1과 본인의 값 이외에 나눈 나머지가 0이면 안되므로 for문을 활용해 i의값을 2부터 result-1까지의 값을 나눠서 나머지가 0인지 아닌지의 판별로 구별한다. 